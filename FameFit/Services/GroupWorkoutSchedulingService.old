//
//  GroupWorkoutSchedulingService.swift
//  FameFit
//
//  Service for managing group workout scheduling
//

import CloudKit
import Combine
import EventKit
import Foundation

// MARK: - Type Aliases
// Use the shared GroupWorkoutInvite struct directly

// MARK: - Group Workout Scheduling Service Protocol

protocol GroupWorkoutSchedulingServicing: AnyObject {
    // Create & Update
    func createGroupWorkout(_ workout: GroupWorkout) async throws -> GroupWorkout
    func updateGroupWorkout(_ workout: GroupWorkout) async throws -> GroupWorkout
    func deleteGroupWorkout(_ workoutId: String) async throws
    
    // Participants
    func joinGroupWorkout(_ workoutId: String, status: ParticipantStatus) async throws
    func leaveGroupWorkout(_ workoutId: String) async throws
    func updateParticipantStatus(_ workoutId: String, status: ParticipantStatus) async throws
    func getParticipants(_ workoutId: String) async throws -> [GroupWorkoutParticipant]
    
    // Discovery
    func fetchUpcomingWorkouts(limit: Int) async throws -> [GroupWorkout]
    func fetchMyWorkouts() async throws -> [GroupWorkout]
    func fetchPublicWorkouts(tags: [String]?, limit: Int) async throws -> [GroupWorkout]
    func searchWorkouts(query: String, filters: WorkoutFilters?) async throws -> [GroupWorkout]
    
    // Invites
    func inviteUser(_ userId: String, to workoutId: String) async throws
    func respondToInvite(_ inviteId: String, accept: Bool) async throws
    func fetchMyInvites() async throws -> [GroupWorkoutInvite]
    
    // Calendar
    func addToCalendar(_ workout: GroupWorkout) async throws
    func removeFromCalendar(_ workout: GroupWorkout) async throws
    
    // Real-time updates
    var workoutUpdatesPublisher: AnyPublisher<GroupWorkout, Never> { get }
}

// MARK: - Workout Filters

struct WorkoutFilters {
    let workoutTypes: [String]?
    let dateRange: DateRange?
    let maxDistance: Double? // in kilometers
    let tags: [String]?
    
    struct DateRange {
        let start: Date
        let end: Date
    }
}

// MARK: - Implementation

final class GroupWorkoutSchedulingService: GroupWorkoutSchedulingServicing {
    private let cloudKitManager: any CloudKitManaging
    private let userProfileService: UserProfileServicing
    private let notificationManager: NotificationManaging
    private let eventStore = EKEventStore()
    
    private let workoutUpdatesSubject = PassthroughSubject<GroupWorkout, Never>()
    var workoutUpdatesPublisher: AnyPublisher<GroupWorkout, Never> {
        workoutUpdatesSubject.eraseToAnyPublisher()
    }
    
    private var subscriptions: [CKSubscription] = []
    
    init(
        cloudKitManager: any CloudKitManaging,
        userProfileService: UserProfileServicing,
        notificationManager: NotificationManaging
    ) {
        self.cloudKitManager = cloudKitManager
        self.userProfileService = userProfileService
        self.notificationManager = notificationManager
        
        Task {
            await setupSubscriptions()
        }
    }
    
    // MARK: - Create & Update
    
    func createGroupWorkout(_ workout: GroupWorkout) async throws -> GroupWorkout {
        FameFitLogger.info("ðŸƒâ€â™‚ï¸ GroupWorkoutSchedulingService.createGroupWorkout called", category: FameFitLogger.social)
        FameFitLogger.debug("  - workout.id: \(workout.id)", category: FameFitLogger.social)
        FameFitLogger.debug("  - workout.name: \(workout.name)", category: FameFitLogger.social)
        FameFitLogger.debug("  - workout.maxParticipants: \(workout.maxParticipants)", category: FameFitLogger.social)
        FameFitLogger.debug("  - workout.scheduledStart: \(workout.scheduledStart)", category: FameFitLogger.social)
        FameFitLogger.debug("  - workout.isPublic: \(workout.isPublic)", category: FameFitLogger.social)
        FameFitLogger.debug("  - workout.tags: \(workout.tags)", category: FameFitLogger.social)
        
        let record = workout.toCKRecord()
        FameFitLogger.debug("ðŸƒâ€â™‚ï¸ Saving workout record to CloudKit", category: FameFitLogger.social)
        let savedRecord = try await cloudKitManager.save(record)
        
        guard let savedWorkout = GroupWorkout(from: savedRecord) else {
            FameFitLogger.error("ðŸƒâ€â™‚ï¸ Failed to parse saved workout record", category: FameFitLogger.social)
            throw GroupWorkoutSchedulingError.invalidData
        }
        
        FameFitLogger.debug("ðŸƒâ€â™‚ï¸ Workout saved successfully, adding creator as participant", category: FameFitLogger.social)
        
        // Automatically add creator as participant
        let currentUserId = try await cloudKitManager.getCurrentUserID()
        FameFitLogger.debug("ðŸƒâ€â™‚ï¸ Current user ID: \(currentUserId)", category: FameFitLogger.social)
        
        let currentProfile = try await userProfileService.fetchCurrentUserProfile()
        FameFitLogger.debug("ðŸƒâ€â™‚ï¸ Current user profile: \(currentProfile.username)", category: FameFitLogger.social)
        
        let participant = GroupWorkoutParticipant(
            id: UUID().uuidString,
            groupWorkoutId: savedWorkout.id,
            userId: currentUserId,
            username: currentProfile.username,
            profileImageURL: currentProfile.profileImageURL,
            status: .joined
        )
        
        let participantRecord = participant.toCKRecord()
        _ = try await cloudKitManager.save(participantRecord)
        
        // Update participant count on the workout
        // Note: We'll skip updating the count here since it's already handled
        // when participants are fetched. This avoids the "record already exists" error.
        var workoutWithUpdatedCount = savedWorkout
        workoutWithUpdatedCount.participantCount = 1 // Creator is the first participant
        
        workoutUpdatesSubject.send(workoutWithUpdatedCount)
        
        return workoutWithUpdatedCount
    }
    
    func updateGroupWorkout(_ workout: GroupWorkout) async throws -> GroupWorkout {
        FameFitLogger.info("ðŸƒâ€â™‚ï¸ GroupWorkoutSchedulingService.updateGroupWorkout called", category: FameFitLogger.social)
        FameFitLogger.debug("  - workout.id: \(workout.id)", category: FameFitLogger.social)
        FameFitLogger.debug("  - workout.name: \(workout.name)", category: FameFitLogger.social)
        FameFitLogger.debug("  - workout.status: \(workout.status)", category: FameFitLogger.social)
        
        // Create updated workout with new timestamp
        let updatedWorkout = GroupWorkout(
            id: workout.id,
            name: workout.name,
            description: workout.description,
            workoutType: workout.workoutType,
            hostId: workout.hostId,
            participantCount: workout.participantCount,
            maxParticipants: workout.maxParticipants,
            scheduledStart: workout.scheduledStart,
            scheduledEnd: workout.scheduledEnd,
            status: workout.status,
            createdTimestamp: workout.createdTimestamp,
            modifiedTimestamp: Date(),
            isPublic: workout.isPublic,
            joinCode: workout.joinCode,
            tags: workout.tags,
            location: workout.location,
            notes: workout.notes
        )
        
        FameFitLogger.debug("ðŸƒâ€â™‚ï¸ Saving updated workout record", category: FameFitLogger.social)
        let record = updatedWorkout.toCKRecord()
        let savedRecord = try await cloudKitManager.save(record)
        
        guard let savedWorkout = GroupWorkout(from: savedRecord) else {
            FameFitLogger.error("ðŸƒâ€â™‚ï¸ Failed to parse updated workout record", category: FameFitLogger.social)
            throw GroupWorkoutSchedulingError.invalidData
        }
        
        FameFitLogger.debug("ðŸƒâ€â™‚ï¸ Workout updated successfully, sending update notification", category: FameFitLogger.social)
        workoutUpdatesSubject.send(savedWorkout)
        
        // Notify participants of update
        await notifyParticipantsOfUpdate(savedWorkout)
        
        return savedWorkout
    }
    
    func deleteGroupWorkout(_ workoutId: String) async throws {
        // Find the workout record
        let predicate = NSPredicate(format: "id == %@", workoutId)
        let records = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkouts",
            predicate: predicate,
            sortDescriptors: nil,
            limit: 1
        )
        
        guard let record = records.first else {
            throw GroupWorkoutSchedulingError.notFound
        }
        
        // Check if current user is the creator
        let currentUserId = try await cloudKitManager.getCurrentUserID()
        guard record["hostId"] as? String == currentUserId else {
            throw GroupWorkoutSchedulingError.unauthorized
        }
        
        // Delete the workout
        try await cloudKitManager.delete(withRecordID: record.recordID)
        
        // Delete all participants
        let participantPredicate = GroupWorkoutQueryBuilder.participantsForWorkoutQuery(workoutId: workoutId)
        let participantRecords = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkoutParticipants",
            predicate: participantPredicate,
            sortDescriptors: nil,
            limit: 100
        )
        
        for participantRecord in participantRecords {
            try await cloudKitManager.delete(withRecordID: participantRecord.recordID)
        }
        
        // Delete all invites
        let invitePredicate = GroupWorkoutQueryBuilder.invitesForWorkoutQuery(workoutId: workoutId)
        let inviteRecords = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkoutInvites",
            predicate: invitePredicate,
            sortDescriptors: nil,
            limit: 100
        )
        
        for inviteRecord in inviteRecords {
            try await cloudKitManager.delete(withRecordID: inviteRecord.recordID)
        }
    }
    
    // MARK: - Participants
    
    func joinGroupWorkout(_ workoutId: String, status: ParticipantStatus) async throws {
        FameFitLogger.info("ðŸƒâ€â™‚ï¸ GroupWorkoutSchedulingService.joinGroupWorkout called", category: FameFitLogger.social)
        FameFitLogger.debug("  - workoutId: \(workoutId)", category: FameFitLogger.social)
        FameFitLogger.debug("  - status: \(status.rawValue)", category: FameFitLogger.social)
        
        let currentUserId = try await cloudKitManager.getCurrentUserID()
        FameFitLogger.debug("ðŸƒâ€â™‚ï¸ Current user ID: \(currentUserId)", category: FameFitLogger.social)
        
        let currentProfile = try await userProfileService.fetchCurrentUserProfile()
        FameFitLogger.debug("ðŸƒâ€â™‚ï¸ Current user profile: \(currentProfile.username)", category: FameFitLogger.social)
        
        // Check if already a participant
        let predicate = GroupWorkoutQueryBuilder.participantInWorkoutQuery(
            workoutId: workoutId,
            userId: currentUserId
        )
        
        FameFitLogger.debug("ðŸƒâ€â™‚ï¸ Checking for existing participant record", category: FameFitLogger.social)
        let existingRecords = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkoutParticipants",
            predicate: predicate,
            sortDescriptors: nil,
            limit: 1
        )
        
        if let existingRecord = existingRecords.first {
            FameFitLogger.debug("ðŸƒâ€â™‚ï¸ Found existing participant record, updating status", category: FameFitLogger.social)
            // Update status
            existingRecord["status"] = status.rawValue
            _ = try await cloudKitManager.save(existingRecord)
        } else {
            FameFitLogger.debug("ðŸƒâ€â™‚ï¸ Creating new participant record", category: FameFitLogger.social)
            // Create new participant
            let participant = GroupWorkoutParticipant(
                id: UUID().uuidString,
                groupWorkoutId: workoutId,
                userId: currentUserId,
                username: currentProfile.username,
                profileImageURL: currentProfile.profileImageURL,
                status: .joined
            )
            
            FameFitLogger.debug("ðŸƒâ€â™‚ï¸ Participant details:", category: FameFitLogger.social)
            FameFitLogger.debug("  - id: \(participant.id)", category: FameFitLogger.social)
            FameFitLogger.debug("  - username: \(participant.username)", category: FameFitLogger.social)
            FameFitLogger.debug("  - status: \(participant.status.rawValue)", category: FameFitLogger.social)
            
            let record = participant.toCKRecord()
            _ = try await cloudKitManager.save(record)
        }
        
        FameFitLogger.debug("ðŸƒâ€â™‚ï¸ Sending join notification", category: FameFitLogger.social)
        // Send notification
        await sendJoinNotification(workoutId: workoutId, status: status)
    }
    
    func leaveGroupWorkout(_ workoutId: String) async throws {
        let currentUserId = try await cloudKitManager.getCurrentUserID()
        
        let predicate = NSPredicate(
            format: "groupWorkoutId == %@ AND userId == %@",
            workoutId,
            currentUserId
        )
        
        let records = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkoutParticipants",
            predicate: predicate,
            sortDescriptors: nil,
            limit: 1
        )
        
        if let record = records.first {
            try await cloudKitManager.delete(withRecordID: record.recordID)
        }
    }
    
    func updateParticipantStatus(_ workoutId: String, status: ParticipantStatus) async throws {
        try await joinGroupWorkout(workoutId, status: status)
    }
    
    func getParticipants(_ workoutId: String) async throws -> [GroupWorkoutParticipant] {
        FameFitLogger.info("ðŸ‘¥ GroupWorkoutSchedulingService.getParticipants called", category: FameFitLogger.social)
        FameFitLogger.debug("  - workoutId: \(workoutId)", category: FameFitLogger.social)
        
        let predicate = GroupWorkoutQueryBuilder.participantsForWorkoutQuery(workoutId: workoutId)
        let sortDescriptors = [GroupWorkoutQueryBuilder.joinedAtAscending]
        
        FameFitLogger.debug("ðŸ‘¥ Fetching participant records from CloudKit", category: FameFitLogger.social)
        let records = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkoutParticipants",
            predicate: predicate,
            sortDescriptors: sortDescriptors,
            limit: 100
        )
        
        FameFitLogger.debug("ðŸ‘¥ Found \(records.count) participant records", category: FameFitLogger.social)
        
        let participants = records.compactMap { GroupWorkoutParticipant(from: $0) }
        FameFitLogger.debug("ðŸ‘¥ Parsed \(participants.count) participants", category: FameFitLogger.social)
        
        for (index, participant) in participants.enumerated() {
            FameFitLogger.debug("  - Participant \(index + 1): \(participant.username) (\(participant.status.rawValue))", category: FameFitLogger.social)
        }
        
        return participants
    }
    
    // MARK: - Discovery
    
    func fetchUpcomingWorkouts(limit: Int) async throws -> [GroupWorkout] {
        FameFitLogger.info("ðŸ“… GroupWorkoutSchedulingService.fetchUpcomingWorkouts called", category: FameFitLogger.social)
        
        let currentUserId = try await cloudKitManager.getCurrentUserID()
        FameFitLogger.debug("ðŸ“… Current user ID: \(currentUserId)", category: FameFitLogger.social)
        
        let now = Date()
        var allWorkoutRecords: [CKRecord] = []
        var workoutIds = Set<String>() // For deduplication
        
        // 1. Get all public upcoming workouts (including those that have started but not ended)
        let publicPredicate = GroupWorkoutQueryBuilder.publicUpcomingWorkoutsQuery(now: now)
        let publicWorkouts = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkouts",
            predicate: publicPredicate,
            sortDescriptors: [GroupWorkoutQueryBuilder.scheduledStartAscending],
            limit: limit
        )
        
        FameFitLogger.debug("ðŸ“… Found \(publicWorkouts.count) upcoming public workouts", category: FameFitLogger.social)
        
        for workout in publicWorkouts {
            let workoutId = workout.recordID.recordName
            if !workoutIds.contains(workoutId) {
                workoutIds.insert(workoutId)
                allWorkoutRecords.append(workout)
            }
        }
        
        // 2. Get private workouts where user is the host (including those that have started but not ended)
        let hostPredicate = GroupWorkoutQueryBuilder.privateHostWorkoutsQuery(userId: currentUserId, now: now)
        let hostWorkouts = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkouts",
            predicate: hostPredicate,
            sortDescriptors: [GroupWorkoutQueryBuilder.scheduledStartAscending],
            limit: limit
        )
        
        FameFitLogger.debug("ðŸ“… Found \(hostWorkouts.count) upcoming private workouts where user is host", category: FameFitLogger.social)
        
        for workout in hostWorkouts {
            let workoutId = workout.recordID.recordName
            if !workoutIds.contains(workoutId) {
                workoutIds.insert(workoutId)
                allWorkoutRecords.append(workout)
            }
        }
        
        // 3. Get private workouts where user is a participant
        // First get all participant records for the user
        let participantPredicate = GroupWorkoutQueryBuilder.participantRecordsForUserQuery(userId: currentUserId)
        let participantRecords = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkoutParticipants",
            predicate: participantPredicate,
            sortDescriptors: nil,
            limit: 200 // Increase limit to get more participant records
        )
        
        FameFitLogger.debug("ðŸ“… Found \(participantRecords.count) participant records for user", category: FameFitLogger.social)
        
        if !participantRecords.isEmpty {
            // Get the workout IDs from participant records
            let participantWorkoutIds = participantRecords.compactMap { record -> String? in
                if let reference = record["groupWorkoutID"] as? CKRecord.Reference {
                    return reference.recordID.recordName
                }
                // Also try as string in case it's stored differently
                return record["groupWorkoutID"] as? String
            }
            
            FameFitLogger.debug("ðŸ“… User is participant in \(participantWorkoutIds.count) workouts", category: FameFitLogger.social)
            
            // Fetch upcoming private workouts and filter by participant IDs
            let privatePredicate = GroupWorkoutQueryBuilder.privateUpcomingWorkoutsQuery(now: now)
            let privateWorkouts = try await cloudKitManager.fetchRecords(
                ofType: "GroupWorkouts",
                predicate: privatePredicate,
                sortDescriptors: [GroupWorkoutQueryBuilder.scheduledStartAscending],
                limit: 500 // Fetch more to ensure we get all participant workouts
            )
            
            FameFitLogger.debug("ðŸ“… Found \(privateWorkouts.count) total upcoming private workouts", category: FameFitLogger.social)
            
            // Filter for workouts where user is a participant
            let participantWorkouts = privateWorkouts.filter { workout in
                participantWorkoutIds.contains(workout.recordID.recordName)
            }
            
            FameFitLogger.debug("ðŸ“… Found \(participantWorkouts.count) upcoming private workouts where user is participant", category: FameFitLogger.social)
            
            for workout in participantWorkouts {
                let workoutId = workout.recordID.recordName
                if !workoutIds.contains(workoutId) {
                    workoutIds.insert(workoutId)
                    allWorkoutRecords.append(workout)
                }
            }
        }
        
        // Sort all workouts by scheduled start date and limit
        let sortedWorkouts = allWorkoutRecords
            .sorted { ($0["scheduledStart"] as? Date ?? Date()) < ($1["scheduledStart"] as? Date ?? Date()) }
            .prefix(limit)
        
        let workouts = Array(sortedWorkouts).compactMap { GroupWorkout(from: $0) }
        
        FameFitLogger.info("ðŸ“… Returning \(workouts.count) upcoming workouts (public: \(publicWorkouts.count), host: \(hostWorkouts.count), participant: \(allWorkoutRecords.count - publicWorkouts.count - hostWorkouts.count))", category: FameFitLogger.social)
        
        return workouts
    }
    
    func fetchMyWorkouts() async throws -> [GroupWorkout] {
        FameFitLogger.info("ðŸ“‹ GroupWorkoutSchedulingService.fetchMyWorkouts called", category: FameFitLogger.social)
        
        let currentUserId = try await cloudKitManager.getCurrentUserID()
        FameFitLogger.debug("ðŸ“‹ Current user ID: \(currentUserId)", category: FameFitLogger.social)
        
        let predicate = NSPredicate(format: "hostID == %@", currentUserId)
        let sortDescriptors = [NSSortDescriptor(key: "scheduledStart", ascending: false)]
        
        FameFitLogger.debug("ðŸ“‹ Fetching workouts with hostID == \(currentUserId)", category: FameFitLogger.social)
        
        let records = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkouts",
            predicate: predicate,
            sortDescriptors: sortDescriptors,
            limit: 100
        )
        
        FameFitLogger.debug("ðŸ“‹ Found \(records.count) workout records where user is host", category: FameFitLogger.social)
        
        // Debug log the records
        for (index, record) in records.enumerated() {
            FameFitLogger.debug("ðŸ“‹ Record \(index):", category: FameFitLogger.social)
            FameFitLogger.debug("  - recordName: \(record.recordID.recordName)", category: FameFitLogger.social)
            FameFitLogger.debug("  - name: \(record["name"] ?? "nil")", category: FameFitLogger.social)
            FameFitLogger.debug("  - hostID: \(record["hostID"] ?? "nil")", category: FameFitLogger.social)
            FameFitLogger.debug("  - scheduledStart: \(record["scheduledStart"] ?? "nil")", category: FameFitLogger.social)
            FameFitLogger.debug("  - isPublic: \(record["isPublic"] ?? "nil")", category: FameFitLogger.social)
        }
        
        let workouts = records.compactMap { record -> GroupWorkout? in
            if let workout = GroupWorkout(from: record) {
                return workout
            } else {
                FameFitLogger.warning("ðŸ“‹ Failed to parse workout record: \(record.recordID.recordName)", category: FameFitLogger.social)
                return nil
            }
        }
        FameFitLogger.info("ðŸ“‹ Parsed \(workouts.count) workouts for My Workouts", category: FameFitLogger.social)
        
        return workouts
    }
    
    func fetchPublicWorkouts(tags: [String]?, limit: Int) async throws -> [GroupWorkout] {
        FameFitLogger.info("ðŸ” GroupWorkoutSchedulingService.fetchPublicWorkouts called", category: FameFitLogger.social)
        FameFitLogger.debug("  - tags: \(tags ?? [])", category: FameFitLogger.social)
        FameFitLogger.debug("  - limit: \(limit)", category: FameFitLogger.social)
        
        var predicateFormat = "isPublic == 1 AND scheduledStart > %@"
        var args: [Any] = [Date() as NSDate]
        
        if let tags = tags, !tags.isEmpty {
            predicateFormat += " AND ANY tags IN %@"
            args.append(tags)
            FameFitLogger.debug("ðŸ” Filtering by tags: \(tags)", category: FameFitLogger.social)
        }
        
        let predicate = NSPredicate(format: predicateFormat, argumentArray: args)
        let sortDescriptors = [NSSortDescriptor(key: "scheduledStart", ascending: true)]
        
        FameFitLogger.debug("ðŸ” Fetching public workouts from CloudKit", category: FameFitLogger.social)
        let records = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkouts",
            predicate: predicate,
            sortDescriptors: sortDescriptors,
            limit: limit
        )
        
        FameFitLogger.debug("ðŸ” Found \(records.count) public workout records", category: FameFitLogger.social)
        
        let workouts = records.compactMap { GroupWorkout(from: $0) }
        FameFitLogger.debug("ðŸ” Parsed \(workouts.count) public workouts", category: FameFitLogger.social)
        
        return workouts
    }
    
    func searchWorkouts(query: String, filters: WorkoutFilters?) async throws -> [GroupWorkout] {
        var predicateFormat = "(name CONTAINS[cd] %@ OR notes CONTAINS[cd] %@ OR location CONTAINS[cd] %@)"
        var args: [Any] = [query, query, query]
        
        if let filters = filters {
            if let types = filters.workoutTypes, !types.isEmpty {
                predicateFormat += " AND workoutType IN %@"
                args.append(types)
            }
            
            if let dateRange = filters.dateRange {
                predicateFormat += " AND scheduledStart >= %@ AND scheduledStart <= %@"
                args.append(dateRange.start as NSDate)
                args.append(dateRange.end as NSDate)
            }
            
            if let tags = filters.tags, !tags.isEmpty {
                predicateFormat += " AND ANY tags IN %@"
                args.append(tags)
            }
        }
        
        let predicate = NSPredicate(format: predicateFormat, argumentArray: args)
        let sortDescriptors = [NSSortDescriptor(key: "scheduledStart", ascending: true)]
        
        let records = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkouts",
            predicate: predicate,
            sortDescriptors: sortDescriptors,
            limit: 50
        )
        
        return records.compactMap { GroupWorkout(from: $0) }
    }
    
    // MARK: - Invites
    
    func inviteUser(_ userId: String, to workoutId: String) async throws {
        let currentUserId = try await cloudKitManager.getCurrentUserID()
        
        let invite = GroupWorkoutInvite(
            groupWorkoutId: workoutId,
            invitedBy: currentUserId,
            invitedUser: userId
        )
        
        let record = invite.toCKRecord()
        _ = try await cloudKitManager.save(record)
        
        // Send push notification
        await sendInviteNotification(to: userId, workoutId: workoutId)
    }
    
    func respondToInvite(_ inviteId: String, accept: Bool) async throws {
        // Find the invite
        let predicate = NSPredicate(format: "id == %@", inviteId)
        let records = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkoutInvites",
            predicate: predicate,
            sortDescriptors: nil,
            limit: 1
        )
        
        guard let inviteRecord = records.first,
              let invite = GroupWorkoutInvite(from: inviteRecord) else {
            throw GroupWorkoutSchedulingError.inviteNotFound
        }
        
        // Delete the invite
        try await cloudKitManager.delete(withRecordID: inviteRecord.recordID)
        
        // If accepted, join the workout
        if accept {
            try await joinGroupWorkout(invite.groupWorkoutId, status: .joined)
        }
    }
    
    func fetchMyInvites() async throws -> [GroupWorkoutInvite] {
        let currentUserId = try await cloudKitManager.getCurrentUserID()
        
        let predicate = NSPredicate(
            format: "invitedUser == %@ AND expiresAt > %@",
            currentUserId,
            Date() as NSDate
        )
        
        let sortDescriptors = [NSSortDescriptor(key: "invitedAt", ascending: false)]
        
        let records = try await cloudKitManager.fetchRecords(
            ofType: "GroupWorkoutInvites",
            predicate: predicate,
            sortDescriptors: sortDescriptors,
            limit: 50
        )
        
        return records.compactMap { GroupWorkoutInvite(from: $0) }
    }
    
    // MARK: - Calendar Integration
    
    func addToCalendar(_ workout: GroupWorkout) async throws {
        FameFitLogger.info("ðŸ“… GroupWorkoutSchedulingService.addToCalendar called", category: FameFitLogger.social)
        FameFitLogger.debug("  - workout.id: \(workout.id)", category: FameFitLogger.social)
        FameFitLogger.debug("  - workout.name: \(workout.name)", category: FameFitLogger.social)
        FameFitLogger.debug("  - workout.scheduledStart: \(workout.scheduledStart)", category: FameFitLogger.social)
        
        let status = await requestCalendarAccess()
        FameFitLogger.debug("ðŸ“… Calendar access status: \(status)", category: FameFitLogger.social)
        
        guard status == .fullAccess else {
            FameFitLogger.error("ðŸ“… Calendar access denied", category: FameFitLogger.social)
            throw GroupWorkoutSchedulingError.calendarAccessDenied
        }
        
        let event = EKEvent(eventStore: eventStore)
        event.title = workout.title
        event.startDate = workout.scheduledDate
        event.endDate = workout.scheduledDate.addingTimeInterval(3600) // 1 hour default
        event.location = workout.location
        event.notes = workout.notes
        event.calendar = eventStore.defaultCalendarForNewEvents
        
        FameFitLogger.debug("ðŸ“… Event details:", category: FameFitLogger.social)
        FameFitLogger.debug("  - title: \(event.title ?? "nil")", category: FameFitLogger.social)
        FameFitLogger.debug("  - startDate: \(event.startDate ?? Date())", category: FameFitLogger.social)
        FameFitLogger.debug("  - endDate: \(event.endDate ?? Date())", category: FameFitLogger.social)
        FameFitLogger.debug("  - location: \(event.location ?? "nil")", category: FameFitLogger.social)
        FameFitLogger.debug("  - calendar: \(event.calendar?.title ?? "nil")", category: FameFitLogger.social)
        
        // Add alarm 30 minutes before
        let alarm = EKAlarm(relativeOffset: -1800) // 30 minutes
        event.addAlarm(alarm)
        FameFitLogger.debug("ðŸ“… Added 30-minute alarm", category: FameFitLogger.social)
        
        do {
            try eventStore.save(event, span: .thisEvent)
            FameFitLogger.debug("ðŸ“… Event saved to calendar successfully", category: FameFitLogger.social)
            
            // Save event identifier to user defaults
            UserDefaults.standard.set(event.eventIdentifier, forKey: "calendar_\(workout.id)")
            FameFitLogger.debug("ðŸ“… Saved event identifier: \(event.eventIdentifier ?? "nil")", category: FameFitLogger.social)
        } catch {
            FameFitLogger.error("ðŸ“… Failed to save event to calendar", error: error, category: FameFitLogger.social)
            throw GroupWorkoutSchedulingError.calendarSaveFailed
        }
    }
    
    func removeFromCalendar(_ workout: GroupWorkout) async throws {
        let status = await requestCalendarAccess()
        guard status == .fullAccess else {
            throw GroupWorkoutSchedulingError.calendarAccessDenied
        }
        
        guard let eventId = UserDefaults.standard.string(forKey: "calendar_\(workout.id)"),
              let event = eventStore.event(withIdentifier: eventId) else {
            return // Event not found, consider it removed
        }
        
        do {
            try eventStore.remove(event, span: .thisEvent)
            UserDefaults.standard.removeObject(forKey: "calendar_\(workout.id)")
        } catch {
            throw GroupWorkoutSchedulingError.calendarRemoveFailed
        }
    }
    
    // MARK: - Private Helpers
    
    private func requestCalendarAccess() async -> EKAuthorizationStatus {
        if #available(iOS 17.0, *) {
            return await withCheckedContinuation { continuation in
                Task {
                    do {
                        let granted = try await eventStore.requestFullAccessToEvents()
                        continuation.resume(returning: granted ? .fullAccess : .denied)
                    } catch {
                        continuation.resume(returning: .denied)
                    }
                }
            }
        } else {
            return await withCheckedContinuation { continuation in
                eventStore.requestAccess(to: .event) { granted, _ in
                    continuation.resume(returning: granted ? .authorized : .denied)
                }
            }
        }
    }
    
    private func setupSubscriptions() async {
        // Subscribe to group workout updates
        let predicate = NSPredicate(value: true)
        let subscription = CKQuerySubscription(
            recordType: "GroupWorkouts",
            predicate: predicate,
            subscriptionID: "GroupWorkoutUpdates",
            options: [.firesOnRecordCreation, .firesOnRecordUpdate, .firesOnRecordDeletion]
        )
        
        let notificationInfo = CKSubscription.NotificationInfo()
        notificationInfo.shouldSendContentAvailable = true
        subscription.notificationInfo = notificationInfo
        
        do {
            let savedSubscription = try await cloudKitManager.database.save(subscription)
            subscriptions.append(savedSubscription)
        } catch {
            print("Failed to setup group workout subscription: \(error)")
        }
    }
    
    private func sendJoinNotification(workoutId: String, status: ParticipantStatus) async {
        // Implementation for sending join notifications
    }
    
    private func sendInviteNotification(to userId: String, workoutId: String) async {
        // Implementation for sending invite notifications
    }
    
    private func notifyParticipantsOfUpdate(_ workout: GroupWorkout) async {
        // Implementation for notifying participants of updates
    }
}

// MARK: - Errors

enum GroupWorkoutSchedulingError: LocalizedError {
    case invalidData
    case notFound
    case unauthorized
    case inviteNotFound
    case calendarAccessDenied
    case calendarSaveFailed
    case calendarRemoveFailed
    
    var errorDescription: String? {
        switch self {
        case .invalidData:
            return "Invalid workout data"
        case .notFound:
            return "Workout not found"
        case .unauthorized:
            return "You don't have permission to perform this action"
        case .inviteNotFound:
            return "Invite not found or expired"
        case .calendarAccessDenied:
            return "Calendar access denied. Please enable in Settings."
        case .calendarSaveFailed:
            return "Failed to save to calendar"
        case .calendarRemoveFailed:
            return "Failed to remove from calendar"
        }
    }
}