//
//  UserSearchViewModelTests.swift
//  FameFitTests
//
//  Unit tests for user search view model
//

import XCTest
import Combine
@testable import FameFit

@MainActor
final class UserSearchViewModelTests: XCTestCase {
    var viewModel: UserSearchViewModel!
    var mockProfileService: MockUserProfileService!
    var mockSocialService: MockSocialFollowingService!
    var cancellables: Set<AnyCancellable>!
    
    override func setUp() {
        super.setUp()
        viewModel = UserSearchViewModel()
        mockProfileService = MockUserProfileService()
        mockSocialService = MockSocialFollowingService()
        cancellables = Set<AnyCancellable>()
        
        // Configure the view model with mock services
        viewModel.configure(
            profileService: mockProfileService,
            socialService: mockSocialService,
            currentUserId: "test-current-user"
        )
    }
    
    override func tearDown() {
        viewModel = nil
        mockProfileService = nil
        mockSocialService = nil
        cancellables = nil
        super.tearDown()
    }
    
    // MARK: - Initialization Tests
    
    func testInitialState() {
        XCTAssertEqual(viewModel.searchText, "")
        XCTAssertEqual(viewModel.searchResults.count, 0)
        XCTAssertEqual(viewModel.suggestedUsers.count, 0)
        XCTAssertFalse(viewModel.isSearching)
        XCTAssertNil(viewModel.error)
        XCTAssertFalse(viewModel.hasSearched)
    }
    
    // MARK: - Search Tests
    
    func testSearch_EmptyQuery() async {
        // When
        await viewModel.search(query: "")
        
        // Then
        XCTAssertEqual(viewModel.searchResults.count, 0)
        XCTAssertFalse(viewModel.isSearching)
        XCTAssertFalse(viewModel.hasSearched)
    }
    
    func testSearch_ShortQuery() async {
        // When
        await viewModel.search(query: "a")
        
        // Then
        XCTAssertEqual(viewModel.searchResults.count, 0)
        XCTAssertFalse(viewModel.isSearching)
        XCTAssertFalse(viewModel.hasSearched)
    }
    
    func testSearch_ValidQuery_Success() async {
        // Given
        let mockProfile = UserProfile(
            id: "search-user-1",
            username: "testuser",
            displayName: "Test User",
            bio: "A test user",
            profileImageURL: nil,
            joinDate: Date(),
            lastActiveDate: Date(),
            isVerified: false,
            privacyLevel: .publicProfile,
            workoutCount: 10,
            totalXP: 500,
            isActive: true
        )
        mockProfileService.mockSearchResults = [mockProfile]
        
        // When
        await viewModel.search(query: "test")
        
        // Then
        XCTAssertFalse(viewModel.isSearching)
        XCTAssertTrue(viewModel.hasSearched)
        XCTAssertEqual(viewModel.searchResults.count, 1)
        XCTAssertEqual(viewModel.searchResults.first?.username, "testuser")
        XCTAssertNil(viewModel.error)
    }
    
    func testSearch_ValidQuery_NoResults() async {
        // Given
        mockProfileService.mockSearchResults = []
        
        // When
        await viewModel.search(query: "nonexistent")
        
        // Then
        XCTAssertFalse(viewModel.isSearching)
        XCTAssertTrue(viewModel.hasSearched)
        XCTAssertEqual(viewModel.searchResults.count, 0)
        XCTAssertNil(viewModel.error)
    }
    
    func testSearch_ValidQuery_Error() async {
        // Given
        mockProfileService.shouldFail = true
        
        // When
        await viewModel.search(query: "test")
        
        // Then
        XCTAssertFalse(viewModel.isSearching)
        XCTAssertTrue(viewModel.hasSearched)
        XCTAssertEqual(viewModel.searchResults.count, 0)
        XCTAssertNotNil(viewModel.error)
    }
    
    func testSearch_LoadingState() async {
        // Given
        let expectation = XCTestExpectation(description: "Search loading state")
        var wasLoading = false
        
        viewModel.$isSearching
            .sink { isSearching in
                if isSearching {
                    wasLoading = true
                    expectation.fulfill()
                }
            }
            .store(in: &cancellables)
        
        // When
        await viewModel.search(query: "test")
        
        // Then
        await fulfillment(of: [expectation], timeout: 1.0)
        XCTAssertTrue(wasLoading)
        XCTAssertFalse(viewModel.isSearching)
    }
    
    // MARK: - Suggested Users Tests
    
    func testLoadSuggestedUsers_Success() async {
        // Given
        let suggestedProfile = UserProfile(
            id: "suggested-user-1",
            username: "suggested",
            displayName: "Suggested User",
            bio: "A suggested user",
            profileImageURL: nil,
            joinDate: Date(),
            lastActiveDate: Date(),
            isVerified: true,
            privacyLevel: .publicProfile,
            workoutCount: 100,
            totalXP: 5000,
            isActive: true
        )
        mockProfileService.mockSuggestedUsers = [suggestedProfile]
        
        // When
        await viewModel.loadSuggestedUsers()
        
        // Then
        XCTAssertEqual(viewModel.suggestedUsers.count, 1)
        XCTAssertEqual(viewModel.suggestedUsers.first?.username, "suggested")
        XCTAssertTrue(viewModel.suggestedUsers.first?.isVerified ?? false)
    }
    
    func testLoadSuggestedUsers_Error() async {
        // Given
        mockProfileService.shouldFail = true
        
        // When
        await viewModel.loadSuggestedUsers()
        
        // Then
        XCTAssertEqual(viewModel.suggestedUsers.count, 0)
        // Should not set error for suggested users failure
        XCTAssertNil(viewModel.error)
    }
    
    // MARK: - Clear Search Tests
    
    func testClearSearch() async {
        // Given
        await viewModel.search(query: "test")
        XCTAssertTrue(viewModel.hasSearched)
        XCTAssertGreaterThan(viewModel.searchResults.count, 0)
        
        // When
        viewModel.clearSearch()
        
        // Then
        XCTAssertEqual(viewModel.searchText, "")
        XCTAssertEqual(viewModel.searchResults.count, 0)
        XCTAssertFalse(viewModel.hasSearched)
        XCTAssertNil(viewModel.error)
    }
    
    // MARK: - Follow Action Tests
    
    func testFollowUser_Success() async {
        // Given
        let userToFollow = UserProfile(
            id: "follow-user",
            username: "followme",
            displayName: "Follow Me",
            bio: "",
            profileImageURL: nil,
            joinDate: Date(),
            lastActiveDate: Date(),
            isVerified: false,
            privacyLevel: .publicProfile,
            workoutCount: 0,
            totalXP: 0,
            isActive: true
        )
        
        // When
        await viewModel.followUser(userToFollow)
        
        // Then
        XCTAssertNil(viewModel.error)
        // Check that follow was called on the social service
        XCTAssertTrue(mockSocialService.relationships["test-current-user"]?.contains("follow-user") ?? false)
    }
    
    func testFollowUser_PrivateProfile() async {
        // Given
        let privateUser = UserProfile(
            id: "private-user",
            username: "private",
            displayName: "Private User",
            bio: "",
            profileImageURL: nil,
            joinDate: Date(),
            lastActiveDate: Date(),
            isVerified: false,
            privacyLevel: .privateProfile,
            workoutCount: 0,
            totalXP: 0,
            isActive: true
        )
        
        // When
        await viewModel.followUser(privateUser)
        
        // Then
        XCTAssertNil(viewModel.error)
        // Should have created a follow request instead
        XCTAssertTrue(mockSocialService.followRequests.contains { $0.targetId == "private-user" })
    }
    
    func testFollowUser_Error() async {
        // Given
        let userToFollow = UserProfile(
            id: "error-user",
            username: "erroruser",
            displayName: "Error User",
            bio: "",
            profileImageURL: nil,
            joinDate: Date(),
            lastActiveDate: Date(),
            isVerified: false,
            privacyLevel: .publicProfile,
            workoutCount: 0,
            totalXP: 0,
            isActive: true
        )
        
        mockSocialService.shouldFailNextAction = true
        mockSocialService.mockError = .rateLimitExceeded(action: "follow", resetTime: Date())
        
        // When
        await viewModel.followUser(userToFollow)
        
        // Then
        XCTAssertNotNil(viewModel.error)
    }
    
    // MARK: - Search Text Binding Tests
    
    func testSearchTextBinding() async {
        // Given
        let expectation = XCTestExpectation(description: "Search text updated")
        var searchTextUpdated = false
        
        viewModel.$searchText
            .dropFirst() // Skip initial value
            .sink { text in
                if text == "new search" {
                    searchTextUpdated = true
                    expectation.fulfill()
                }
            }
            .store(in: &cancellables)
        
        // When
        viewModel.searchText = "new search"
        
        // Then
        await fulfillment(of: [expectation], timeout: 1.0)
        XCTAssertTrue(searchTextUpdated)
        XCTAssertEqual(viewModel.searchText, "new search")
    }
    
    // MARK: - Privacy Filtering Tests
    
    func testSearch_FiltersByPrivacy() async {
        // Given
        let publicUser = UserProfile(
            id: "public-user",
            username: "public",
            displayName: "Public User",
            bio: "",
            profileImageURL: nil,
            joinDate: Date(),
            lastActiveDate: Date(),
            isVerified: false,
            privacyLevel: .publicProfile,
            workoutCount: 0,
            totalXP: 0,
            isActive: true
        )
        
        let privateUser = UserProfile(
            id: "private-user",
            username: "private",
            displayName: "Private User",
            bio: "",
            profileImageURL: nil,
            joinDate: Date(),
            lastActiveDate: Date(),
            isVerified: false,
            privacyLevel: .privateProfile,
            workoutCount: 0,
            totalXP: 0,
            isActive: true
        )
        
        // Configure mock to return both users but service should filter
        mockProfileService.mockSearchResults = [publicUser, privateUser]
        
        // When
        await viewModel.search(query: "user")
        
        // Then
        // Both should be returned (privacy filtering happens at service level)
        XCTAssertEqual(viewModel.searchResults.count, 2)
    }
    
    // MARK: - Duplicate Results Tests
    
    func testSearch_NoDuplicateResults() async {
        // Given
        let user = UserProfile(
            id: "unique-user",
            username: "unique",
            displayName: "Unique User",
            bio: "",
            profileImageURL: nil,
            joinDate: Date(),
            lastActiveDate: Date(),
            isVerified: false,
            privacyLevel: .publicProfile,
            workoutCount: 0,
            totalXP: 0,
            isActive: true
        )
        
        mockProfileService.mockSearchResults = [user, user] // Duplicate
        
        // When
        await viewModel.search(query: "unique")
        
        // Then
        // Should deduplicate results (if the viewModel does this)
        let uniqueIds = Set(viewModel.searchResults.map { $0.id })
        XCTAssertEqual(uniqueIds.count, viewModel.searchResults.count)
    }
    
    // MARK: - Performance Tests
    
    func testSearchPerformance() {
        measure {
            Task {
                await viewModel.search(query: "test")
            }
        }
    }
    
    func testLoadSuggestedUsersPerformance() {
        measure {
            Task {
                await viewModel.loadSuggestedUsers()
            }
        }
    }
    
    // MARK: - Edge Cases
    
    func testSearch_SpecialCharacters() async {
        // Given
        let query = "user@#$%"
        
        // When
        await viewModel.search(query: query)
        
        // Then - Should handle special characters without crashing
        XCTAssertFalse(viewModel.isSearching)
        XCTAssertTrue(viewModel.hasSearched)
    }
    
    func testSearch_VeryLongQuery() async {
        // Given
        let longQuery = String(repeating: "a", count: 1000)
        
        // When
        await viewModel.search(query: longQuery)
        
        // Then - Should handle long queries without crashing
        XCTAssertFalse(viewModel.isSearching)
        XCTAssertTrue(viewModel.hasSearched)
    }
    
    func testSearch_UnicodeCharacters() async {
        // Given
        let unicodeQuery = "用户测试🎉"
        
        // When
        await viewModel.search(query: unicodeQuery)
        
        // Then - Should handle unicode without crashing
        XCTAssertFalse(viewModel.isSearching)
        XCTAssertTrue(viewModel.hasSearched)
    }
    
    // MARK: - Concurrent Search Tests
    
    func testConcurrentSearches() async {
        // Given
        let expectation = XCTestExpectation(description: "Concurrent searches")
        expectation.expectedFulfillmentCount = 3
        
        // When - Multiple concurrent searches
        Task {
            await viewModel.search(query: "test1")
            expectation.fulfill()
        }
        
        Task {
            await viewModel.search(query: "test2")
            expectation.fulfill()
        }
        
        Task {
            await viewModel.search(query: "test3")
            expectation.fulfill()
        }
        
        // Then
        await fulfillment(of: [expectation], timeout: 5.0)
        XCTAssertFalse(viewModel.isSearching)
    }
    
    // MARK: - Error Recovery Tests
    
    func testErrorRecovery_AfterFailedSearch() async {
        // Given - Failed search
        mockProfileService.shouldFail = true
        await viewModel.search(query: "fail")
        XCTAssertNotNil(viewModel.error)
        
        // When - Successful search after failure
        mockProfileService.shouldFail = false
        let successProfile = UserProfile(
            id: "success-user",
            username: "success",
            displayName: "Success User",
            bio: "",
            profileImageURL: nil,
            joinDate: Date(),
            lastActiveDate: Date(),
            isVerified: false,
            privacyLevel: .publicProfile,
            workoutCount: 0,
            totalXP: 0,
            isActive: true
        )
        mockProfileService.mockSearchResults = [successProfile]
        await viewModel.search(query: "success")
        
        // Then
        XCTAssertNil(viewModel.error)
        XCTAssertEqual(viewModel.searchResults.count, 1)
    }
    
    // MARK: - Search Results Validation
    
    func testSearchResults_DoNotIncludeCurrentUser() async {
        // Given
        let currentUser = UserProfile(
            id: "test-current-user",
            username: "currentuser",
            displayName: "Current User",
            bio: "",
            profileImageURL: nil,
            joinDate: Date(),
            lastActiveDate: Date(),
            isVerified: false,
            privacyLevel: .publicProfile,
            workoutCount: 0,
            totalXP: 0,
            isActive: true
        )
        
        let otherUser = UserProfile(
            id: "other-user",
            username: "otheruser",
            displayName: "Other User",
            bio: "",
            profileImageURL: nil,
            joinDate: Date(),
            lastActiveDate: Date(),
            isVerified: false,
            privacyLevel: .publicProfile,
            workoutCount: 0,
            totalXP: 0,
            isActive: true
        )
        
        mockProfileService.mockSearchResults = [currentUser, otherUser]
        
        // When
        await viewModel.search(query: "user")
        
        // Then - Should filter out current user
        let currentUserInResults = viewModel.searchResults.contains { $0.id == "test-current-user" }
        XCTAssertFalse(currentUserInResults, "Search results should not include current user")
    }
}